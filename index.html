<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./assets/styles.css">
	<link rel="stylesheet" href="./assets/hljs.css">

	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Roboto&family=Ubuntu&display=swap" rel="stylesheet">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/3.0.7/marked.js"></script>
	<script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script>
	<script src="https://kit.fontawesome.com/c1798fb82d.js" crossorigin="anonymous"></script>
	<title>Snap Documentation</title>

	<link rel="icon" href="./favicon.ico">
</head>
<body>
	<div id="app"></div>

	<script src="https://unpkg.com/vue@next"></script>
	<script src="https://unpkg.com/vue-router@4"></script>

	<script>
		function modifyLinks(markdown) {
			var replaces = [
				{ a: "(https://searchspring.github.io/snap/#/start-setup)", b: "(#/start-setup)"},
				{ a: "(https://snapi.kube.searchspring.io/api/v1/#tag/Meta)", b: "(#/api-docs#Meta)"},
				{ a: "(https://snapi.kube.searchspring.io/api/v1/)", b: "(#/api-docs)"},
				{ a: "(https://searchspring.github.io/snapi-explorer/)", b: "(#/api-explorer)"},	
				
				{ a: "(https://github.com/searchspring/snap/blob/main/docs/SEARCH.md)", b: "(#/advanced-search)"},
				{ a: "(https://github.com/searchspring/snap/blob/main/docs/PREACT_DISPLAYING_DATA.md)", b: "(#/start-preact-events)"},

				{ a: "https://github.com/searchspring/snap/blob/main/images/snap-dependencies.jpg?raw=true", b: "./images/snap-dependencies.jpg"},
				{ a: "https://github.com/searchspring/snap/blob/main/images/snap-dependencies.png?raw=true", b: "./images/snap-dependencies.png"},
				{ a: "https://github.com/searchspring/snap/blob/main/images/logger-example.png?raw=true", b: "./images/logger-example.png"},
				{ a: "https://github.com/searchspring/snap/blob/main/images/emojis.png?raw=true", b: "./images/emojis.png"},
				{ a: "https://github.com/searchspring/snap/blob/main/images/colors.png?raw=true", b: "./images/colors.png"},
				{ a: "https://github.com/searchspring/snap/blob/main/images/colors.png?raw=true", b: "./images/colors.png"},
				{ a: "https://github.com/searchspring/snap/blob/main/images/nebo404.svg?raw=true", b: "./images/nebo404.svg"},

				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-client)", b: "(#/package-client)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-store-mobx)", b: "(#/package-storeMobx)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-url-manager)", b: "(#/package-urlManager)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-url-manager/src/Translators/Url)", b: "(#/package-urlManager-translators-url)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-event-manager)", b: "(#/package-eventManager)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-profiler)", b: "(#/package-profiler)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-logger)", b: "(#/package-logger)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-controller)", b: "(#/package-controller)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-toolbox)", b: "(#/package-toolbox)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-tracker)", b: "(#/package-tracker)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-preact-components)", b: "(#/components-preact)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-preact)", b: "(#/start-preact)"},
				
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-toolbox/src/DomTargeter)", b: "(#/package-toolbox-domTargeter)"},
				
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-store-mobx/src/Storage)", b: "(#/package-storeMobx-storage)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-store-mobx/src/Search)", b: "(#/package-storeMobx-search)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-store-mobx/src/Abstract)", b: "(#/package-storeMobx-abstract)"},

				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-controller/src/Search)", b: "(#/package-controller-search)" },
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-controller/src/Autocomplete)", b: "(#/package-controller-autocomplete)" },
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-controller/src/Recommendation)", b: "(#/package-controller-recommendation)" },
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-controller/src/Finder)", b: "(#/package-controller-finder)" },

				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-url-manager/src/Translators)", b: "(#/package-urlManager-translators)" },
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-url-manager/src/linkers)", b: "(#/package-urlManager-linkers)" },
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-url-manager/src/Translators/Url)", b: "(#/package-urlManager-translators-url)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-url-manager/src/Translators/QueryString)", b: "(#/package-urlManager-translators-queryString)"},
				{ a: "(https://github.com/searchspring/snap/tree/main/packages/snap-url-manager/src/linkers/react)", b: "(#/package-urlManager-linkers-react)"},

				{ a: "(https://searchspring.github.io/snap/)", b: "(#/)"},
			];
			replaces.forEach(function(replace) {
				markdown = markdown.replaceAll(replace.a, replace.b);
			});
			return markdown
		}
		
		import('./docs/documents.js').then(function (_) {
			const documents = _.default;
			const App = {
				data() {
					return {
						documents
					}
				},
				computed: {
					routes() {
						const routeMap = this.documents.reduce((acc, section) => {
							section?.links?.forEach((link) => {
								if (link.route) {
									acc[link.route] = link;
								}

								link?.links?.forEach((sublink) => {
									if (sublink.route) {
										acc[sublink.route] = sublink;
									}
								})
							});

							return acc;
						}, {});

						return routeMap;
					},
				},
				template: `
					<Navigation :documents="documents"></Navigation>

					<div id="content">
						<router-view :routes="routes"></router-view>
					</div>
				`
			}

			const app = Vue.createApp(App);

			app.component('Content', { 
				props: ['routes'],
				template: `
					<iframe v-if="routeData.type == 'iframe'" :src="routeData.url" id="frame" @load="onLoad"></iframe>
					<Markdown v-else-if="routeData.type == 'markdown'" :src="routeData.url" />
					<div id="searchWrapper"></div>
				`,
				computed: {
					currentRoute() {
						return this.$route.path;
					},
					routeData() {
						const params = decodeURIComponent(window.location.href.split('?params=')[1] || '');

						// check if base URL (minus params) has changed
						// if it hasn't maybe do something different like push state in iframe with new URL

						// get previous route and compare it to currentRoute
						const previousFullRoute = localStorage.getItem('ssDocsPreviousRoute');
						const [previousRoute, previousRouteParams] = previousFullRoute.split('?params=');
						console.log('previousFullRoute', previousFullRoute);
						console.log('previousRoute', previousRoute);
						console.log('previousRouteParams', previousRouteParams);
						// previousRoute == 'components-preact'
						console.log('currentRoute', this.currentRoute);
						
						if (params && this.routes[this.currentRoute] && this.routes[this.currentRoute].url && this.routes[this.currentRoute].type === 'iframe') {
							console.log(`need to goto: ${this.routes[this.currentRoute].url}${params}`);
							if (previousRoute == this.currentRoute) {
								return { type: 'iframe', url: `${this.routes[this.currentRoute].url}`}
							} else {
								// return { type: 'iframe', url: `${this.routes[this.currentRoute].url}`}
								return { type: 'iframe', url: `${this.routes[this.currentRoute].url}${params}`}
							}
							
						}

						return this.routes[this.currentRoute] || { type: 'markdown', url: './docs/404.md' };
					}
				},
				
				methods: {
					onLoad() {
						const mutations = [];
						// Select the node that will be observed for mutations
						const targetNode = document.getElementById('frame').contentWindow.document.querySelector('title');

						/*
							new MutationObserver(function() {console.log(document.title);}).observe(document.querySelector('title'),{ childList: true });
						*/
	
						// Options for the observer (which mutations to observe)
						// const config = { attributes: true, childList: true, subtree: true };
						const config = { characterData: true, attributes: true, childList: true, subtree: true};
						
	
						// Callback function to execute when mutations are observed
						const callback = function(mutationsList, observer) {
							
							mutations.push(mutationsList[0])
							if(mutationsList.length && mutations.length > 1) {
								const url = mutationsList[0].target.baseURI;
								const params = encodeURIComponent(`?${url.split('?')[1]}`);
								const fullRoute = window.location.href.split('#')[1] // '/components-preact?params=%3Fpath%3D%2Fdocs%2FOrganisms-Autocomplete'
								const route = fullRoute.split('?')[0]; // '/components-preact'
								const newRoute = `${route}?params=${params}`;
								window.location.hash = newRoute;
							}
						};
	
						// Create an observer instance linked to the callback function
						const observer = new MutationObserver(callback);
	
						// Start observing the target node for configured mutations
						observer.observe(targetNode, config);
	
						// setTimeout(() => {
						// 	// this is the initial call that works in FF (and Chrome/Safari naturally)
						// 	console.log("targetNode", targetNode)
	
						// 	const retargetNode = document.getElementById('frame').contentWindow.document.body;
						// 	console.log("retargetNode", retargetNode)
						// 	observer.observe(targetNode, config);
						// }, 3000);
	
						// Later, you can stop observing
						// observer.disconnect();
					},
				}
				
			});

			app.component('Markdown', { 
				props: ['src'],
				template: `
					<div id="markdown" v-html="markedHTML"></div>
				`,
				data() {
					return {
						markdown: '',
					}
				},
				watch: {
					src() {
						this.getMarkdown(this.src);
					}
				},
				computed: {
					markedHTML() {
						return marked(this.markdown);
					}
				},
				created() {
					this.getMarkdown(this.src);
				},
				updated() {
					window.highlight();
				},
				methods: {
					async getMarkdown(file) {
						this.markdown = '';
						const response = await fetch(file);
						let text = await response.text()
						this.iframe = "";
						this.markdown = modifyLinks(text);
					}
				}
			});

			app.component('Link', {
				props: ['link', 'active'],
				template: `
					<router-link v-if="link.route" :key="link.route" :to="'' + link.route" :class="{ 'active': active }">
						{{link.label}}
					</router-link>
			
					<a v-else-if="link.type == 'external'" :href="link.url" target="_blank">
						{{link.label}}
						<i v-if="link.icon" :class="link.icon"></i>
					</a>
				`,
			});

			app.component('Navigation', {
				props: ['documents'],
				components: ['Link'],
				data() {
					return {
						navVisible: true,
					}
				},
				computed: {
					currentRoute() {
						return this.$route.path;
					}
				},
				methods: {
					toggleNav() {
						this.navVisible = !this.navVisible
					},
					inRoute(link) {
						if (link?.route) {
							const includedRoutes = [link.route];

							link.links?.forEach(sublink => includedRoutes.push(sublink.route));

							return includedRoutes.includes(this.currentRoute);
						}
					}
				},
				template: `
					<div id="navigation-wrapper">
						<router-link :key="'/'" :to="'/'">
							<div id="header">
								<div class="logo-container">
									<img src="./images/logo-snap.svg"/>
								</div>
							</div>
						</router-link>
						<span class="collapseNav" @click="toggleNav"><i class="fas fa-bars fa-2x"></i></span>
						<div id="search-container">
								<h3> Search </h3>
								<input id="searchBar" type="text" />
							</div>
						<div id="navigation" :class="{ visible: navVisible }" >
							<div v-for="section in documents" class="section">
								<h3>{{ section.categoryName }}</h3>
								<ul class="links">
									<li v-for="link in section.links">
										<Link :link="link" :active="inRoute(link)" />

										<ul v-if="link.links && inRoute(link)" class="sublinks">
											<li v-for="sublink in link.links">
												<Link :link="sublink" :active="inRoute(sublink)"/>
											</li>
										</ul>
									</li>
								</ul>
							</div>
						</div>
					</div>
				`,
			});

			const routes = [
				{ path: '/',      component: app.component('Content') },
				{ path: '/:path', component: app.component('Content') },
			]

			const router = VueRouter.createRouter({
				history: VueRouter.createWebHashHistory(),
				routes,
			});
			

			router.beforeEach((to, from) => {
				console.log('in router beforeEach', to, from);
				localStorage.setItem('ssDocsPreviousRoute', from.fullPath);
			})

			app.use(router);

			app.mount('#app');

			window.highlight = function() {
				document.querySelectorAll('pre code').forEach((block) => {
					hljs.highlightBlock(block);
				});
			}
		})
	</script>

</body>
<script>
	// document.querySelector("iframe").addEventListener('load', function() {
	// 	console.log("iframe loaded")
	// 	console.log(document.querySelector("iframe").contentWindow.location.href)
	// })

</script>
</html>