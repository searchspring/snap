<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./assets/styles.css">
	<link rel="stylesheet" href="./assets/hljs.css">

	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Roboto&family=Ubuntu&display=swap" rel="stylesheet">
	<script src="https://cdn.jsdelivr.net/npm/marked@3.0.8/lib/marked.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/highlight.min.js"></script>
	<script src="https://kit.fontawesome.com/c1798fb82d.js" crossorigin="anonymous"></script>
	<title>Snap Documentation</title>

	<link rel="icon" href="./athos_favicon.svg">

	<script src="https://snapui.searchspring.io/vrntn7/bundle.js" id="searchspring-context"></script>
</head>
<body>
	<div id="app"></div>

	<script src="https://cdn.jsdelivr.net/npm/vue@3.4.5"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue-router@4"></script>

	<script>
		function flattenDocumentLinks(docs) {
			const flattened = [];
			function traverse(links) {
				if (!Array.isArray(links)) return;
				links.forEach(link => {
					flattened.push(link);
					if (link.links && Array.isArray(link.links)) {
						traverse(link.links);
					}
				});
			}
			docs.forEach(doc => {
				if (doc.links && Array.isArray(doc.links)) {
					traverse(doc.links);
				}
			});
			return flattened;
		}
		
		import('./docs/documents.js').then(function (_) {
			const documents = _.default;
			const replaces = flattenDocumentLinks(documents)
				.filter(link => link.type === 'markdown')
				.map(link => {
					const urls = Array.isArray(link.url) ? link.url : [link.url];
					return urls.map(url => {
						const transformedUrl = url.replace('./', 'https://github.com/searchspring/snap/blob/main/')
						return { a: `(${transformedUrl})`, b: `(#${link.route})` }
					})
				})
				.flat()
				.concat([
					// other links
				]);
			
			const modifyLinks = (markdown) => {
				replaces.forEach(function(replace) {
					markdown = markdown.replaceAll(replace.a, replace.b);
				});
				return markdown
			}
			const App = {
				data() {
					return {
						documents
					}
				},
				computed: {
					routes() {
						const routeMap = this.documents.reduce((acc, section) => {
							section?.links?.forEach((link) => {
								if (link.route) {
									acc[link.route] = link;
								}

								link?.links?.forEach((sublink) => {
									if (sublink.route) {
										acc[sublink.route] = sublink;
									}
									if (sublink?.links) {
										sublink.links.forEach((subsublink) => {
											if (subsublink.route) {
												acc[subsublink.route] = subsublink;
											}
										})
									}
								})
							});

							return acc;
						}, {});

						return routeMap;
					},
				},
				template: `
					<Navigation :documents="documents"></Navigation>

					<div id="content">
						<router-view :routes="routes"></router-view>
					</div>
					<div id="ac-overlay"></div>
				`
			}

			const app = Vue.createApp(App);

			app.component('Content', { 
				props: ['routes'],
				template: `
					<iframe v-if="routeData.type == 'iframe'" :src="routeData.url" id="frame" @load="onLoad"></iframe>
					<Markdown v-else-if="routeData.type == 'markdown'" :src="routeData.url" />
					<div id="searchWrapper"></div>
				`,
				computed: {
					currentRoute() {
						return this.$route.path;
					},
					routeData() {
						const params = decodeURIComponent(window.location.href.split('?params=')[1] || '');

						if (params && this.routes[this.currentRoute] && this.routes[this.currentRoute].url && this.routes[this.currentRoute].type === 'iframe') {
							const currentiFrameSrc = document.querySelector('iframe')?.src;
							let url = currentiFrameSrc || `${this.routes[this.currentRoute].url}${params}`;
							if(params.includes('&ac')) {
								url = `${this.routes[this.currentRoute].url}${params}`;
							}
							if(url.startsWith('http') && url.includes('/packages/')) {
								url = `./packages/${url.split('/packages/')[1]}`
							}
							return { type: 'iframe', url }
						}

						return this.routes[this.currentRoute] || { type: 'markdown', url: './docs/404.md' };
					}
				},
				
				methods: {
					onLoad() {
						const mutations = [];
						// Select the node that will be observed for mutations
						const targetNode = document.getElementById('frame').contentWindow.document.querySelector('title');
	
						// Options for the observer (which mutations to observe)
						const config = { characterData: true, attributes: true, childList: true, subtree: true};
						
						// Callback function to execute when mutations are observed
						const callback = function(mutationsList, observer) {
							
							mutations.push(mutationsList[0])
							if(mutationsList.length && mutations.length > 1) {
								const url = mutationsList[0].target.baseURI;
								const params = encodeURIComponent(`?${url.split('?')[1]}`);
								const fullRoute = window.location.href.split('#')[1] // '/components-preact?params=%3Fpath%3D%2Fdocs%2FOrganisms-Autocomplete'
								const route = fullRoute.split('?')[0]; // '/components-preact'
								const newRoute = `${route}?params=${params}`;
								window.location.hash = newRoute;
							}
						};
	
						// Create an observer instance linked to the callback function
						const observer = new MutationObserver(callback);
	
						// Start observing the target node for configured mutations
						observer.observe(targetNode, config);
					},
				}
				
			});

			app.component('Markdown', { 
				props: ['src'],
				template: `
					<div id="markdown" v-html="markedHTML"></div>
				`,
				data() {
					return {
						markdown: '',
					}
				},
				watch: {
					src() {
						this.getMarkdown(this.src);
					}
				},
				computed: {
					markedHTML() {
						return marked(this.markdown);
					}
				},
				created() {
					this.getMarkdown(this.src);
				},
				updated() {
					window.highlight();
				},
				methods: {
					async getMarkdown(file) {
						if (Array.isArray(file)) {
							this.markdown = '';
							file.forEach(async (file) => {
								const response = await fetch(file);
								let text = await response.text()
								this.markdown += '\n' + modifyLinks(text);
							});
						} else {
							this.markdown = '';
							const response = await fetch(file);
							let text = await response.text()
							this.iframe = "";
							this.markdown = modifyLinks(text);
						}
					}
				}
			});

			app.component('Link', {
				props: ['link', 'active'],
				template: `
					<router-link v-if="link.route && !link.hidden" :key="link.route" :to="'' + link.route" :class="{ 'active': active }">
						{{link.label}}
					</router-link>
			
					<a v-else-if="link.type == 'external'" :href="link.url" target="_blank">
						{{link.label}}
						<i v-if="link.icon" :class="link.icon"></i>
					</a>
				`,
			});

			app.component('Navigation', {
				props: ['documents'],
				components: ['Link'],
				data() {
					return {
						navVisible: true,
					}
				},
				computed: {
					currentRoute() {
						return this.$route.path;
					}
				},
				methods: {
					toggleNav() {
						this.navVisible = !this.navVisible
					},
					inRoute(link) {
						if (link?.route) {
							const includedRoutes = [link.route];

							link.links?.forEach(sublink => {
								includedRoutes.push(sublink.route);
								if (sublink?.links) {
									sublink.links.forEach(subsublink => includedRoutes.push(subsublink.route));
								}
							});

							return includedRoutes.includes(this.currentRoute);
						}
					}
				},
				template: `
					<div id="navigation-wrapper">
						<router-link :key="'/'" :to="'/'">
							<div id="header">
								<div class="logo-container">
									<img src="./images/logo-snap.svg"/>
								</div>
							</div>
						</router-link>
						<span class="collapseNav" @click="toggleNav"><i class="fas fa-bars fa-2x"></i></span>
						<div id="search-container">
							</div>
						<div id="navigation" :class="{ visible: navVisible }" >
							<div v-for="section in documents" class="section">
								<h3>{{ section.categoryName }}</h3>
								<ul class="links">
									<li v-for="link in section.links">
										<Link :link="link" :active="inRoute(link)" />

										<ul v-if="link.links && inRoute(link)" class="sublinks">
											<li v-for="sublink in link.links">
												<Link :link="sublink" :active="inRoute(sublink)"/>
												<ul v-if="sublink?.links && inRoute(sublink)" class="sublinks">
													<li v-for="subsublink in sublink.links">
														<Link :link="subsublink" :active="inRoute(subsublink)"/>
													</li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</div>
						</div>
					</div>
				`,
			});

			const routes = [
				{ path: '/',      component: app.component('Content') },
				{ path: '/:path', component: app.component('Content') },
			]

			const router = VueRouter.createRouter({
				history: VueRouter.createWebHashHistory(),
				routes,
			});

			app.use(router);

			app.mount('#app');

			window.highlight = function() {
				document.querySelectorAll('pre code').forEach((block) => {
					hljs.highlightBlock(block);
				});
			}
		})
	</script>

</body>
</html>
